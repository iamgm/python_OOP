class TicTacToe:
    def __init__(self):
        self.N = 3
        self.pole = tuple(tuple(Cell() for y in range(self.N)) \
                            for _ in range(self.N))

    def clear(self):
        for row in self.pole:
            for c in row:
                c.value = 0
                c.is_free = True
    
    def __getitem__(self, i):
        row, col = i
        if type(row) == slice:
            return tuple(x[col].value for x in self.pole)
        if type(col) == slice:
            return tuple(x.value for x in self.pole[row])
        return self.pole[row][col].value

    def __setitem__(self, i, value):
        row, col = i
        self.validate_idx(row)
        self.validate_idx(col)
        if not self.pole[row][col].is_free:
            raise ValueError('клетка уже занята')
        self.pole[row][col].value = value
        self.pole[row][col].is_free = False

    def validate_idx(self, i):
        if not(isinstance(i, int) and (0 <= i < 3)):
            raise IndexError('неверный индекс клетки')

class Cell:
    def __init__(self):
        self.is_free = True
        self.value = 0

# Подвиг 8. Вам нужно реализовать в программе игровое поле для игры "Крестики-нолики". Для этого требуется объявить класс TicTacToe (крестики-нолики), объекты которого создаются командой:

# game = TicTacToe()
# Каждый объект game должен иметь публичный атрибут:

# pole - игровое поле: кортеж размером 3х3 с объектами класса Cell.

# Каждая клетка игрового поля представляется объектом класса Cell и создается командой:

# cell = Cell()
# Объекты класса Cell должны иметь следующие публичные локальные атрибуты:

# is_free - True, если клетка свободна; False в противном случае;
# value - значение поля: 1 - крестик; 2 - нолик (по умолчанию 0).

# Также с каждым объектом класса Cell должна работать функция:

# bool(cell)
# которая возвращает True, если клетка свободна (cell.is_free=True) и False в противном случае.

# Класс TicTacToe должен иметь следующий метод:

# clear() - очистка игрового поля (все клетки заполняются нулями и переводятся в закрытое состояние);

# А объекты этого класса должны иметь следующую функциональность (обращение по индексам):

# game[0, 0] = 1 # установка нового значения, если поле закрыто
# res = game[1, 1] # получение значения центральной ячейки поля (возвращается число)
# Если указываются некорректные индексы, то должно генерироваться исключение командой:

# raise IndexError('неверный индекс клетки')
# Если идет попытка присвоить новое значение в открытую клетку поля, то генерировать исключение:

# raise ValueError('клетка уже занята')
# Также должны быть реализованы следующие срезы при обращении к клеткам игрового поля:

# slice_1 = game[:, indx] # выбираются все элементы (кортеж) столбца с индексом indx
# slice_2 = game[indx, :] # выбираются все элементы (кортеж) строки с индексом indx
# Пример использования классов (эти строчки в программе не писать):

# game = TicTacToe()
# game.clear()
# game[0, 0] = 1
# game[1, 0] = 2
# # формируется поле:
# # 1 0 0
# # 2 0 0
# # 0 0 0
# game[3, 2] = 2 # генерируется исключение IndexError
# if game[0, 0] == 0:
#     game[0, 0] = 2
# v1 = game[0, :]  # 1, 0, 0
# v2 = game[:, 0]  # 1, 2, 0
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

# P.P.S. При передаче среза в магических методах __setitem__() и __getitem__() параметр индекса становится объектом класса slice. Его можно указывать непосредственно в квадратных скобках упорядоченных коллекций (списков, кортежей и т.п.).